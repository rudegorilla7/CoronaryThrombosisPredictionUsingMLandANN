<html>
<head>
<title>session.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
session.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;PipSession and supporting code, containing all pip-specific 
network request configuration and behavior. 
&quot;&quot;&quot;</span>

<span class="s2"># When mypy runs on Windows the call to distro.linux_distribution() is skipped</span>
<span class="s2"># resulting in the failure:</span>
<span class="s2">#</span>
<span class="s2">#     error: unused 'type: ignore' comment</span>
<span class="s2">#</span>
<span class="s2"># If the upstream module adds typing, this comment should be removed. See</span>
<span class="s2"># https://github.com/nir0s/distro/pull/269</span>
<span class="s2">#</span>
<span class="s2"># mypy: warn-unused-ignores=False</span>

<span class="s3">import </span><span class="s1">email.utils</span>
<span class="s3">import </span><span class="s1">ipaddress</span>
<span class="s3">import </span><span class="s1">json</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">mimetypes</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">platform</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">urllib.parse</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">Dict</span><span class="s3">, </span><span class="s1">Iterator</span><span class="s3">, </span><span class="s1">List</span><span class="s3">, </span><span class="s1">Mapping</span><span class="s3">, </span><span class="s1">Optional</span><span class="s3">, </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">Tuple</span><span class="s3">, </span><span class="s1">Union</span>

<span class="s3">from </span><span class="s1">pip._vendor </span><span class="s3">import </span><span class="s1">requests</span><span class="s3">, </span><span class="s1">urllib3</span>
<span class="s3">from </span><span class="s1">pip._vendor.cachecontrol </span><span class="s3">import </span><span class="s1">CacheControlAdapter</span>
<span class="s3">from </span><span class="s1">pip._vendor.requests.adapters </span><span class="s3">import </span><span class="s1">BaseAdapter</span><span class="s3">, </span><span class="s1">HTTPAdapter</span>
<span class="s3">from </span><span class="s1">pip._vendor.requests.models </span><span class="s3">import </span><span class="s1">PreparedRequest</span><span class="s3">, </span><span class="s1">Response</span>
<span class="s3">from </span><span class="s1">pip._vendor.requests.structures </span><span class="s3">import </span><span class="s1">CaseInsensitiveDict</span>
<span class="s3">from </span><span class="s1">pip._vendor.urllib3.connectionpool </span><span class="s3">import </span><span class="s1">ConnectionPool</span>
<span class="s3">from </span><span class="s1">pip._vendor.urllib3.exceptions </span><span class="s3">import </span><span class="s1">InsecureRequestWarning</span>

<span class="s3">from </span><span class="s1">pip </span><span class="s3">import </span><span class="s1">__version__</span>
<span class="s3">from </span><span class="s1">pip._internal.metadata </span><span class="s3">import </span><span class="s1">get_default_environment</span>
<span class="s3">from </span><span class="s1">pip._internal.models.link </span><span class="s3">import </span><span class="s1">Link</span>
<span class="s3">from </span><span class="s1">pip._internal.network.auth </span><span class="s3">import </span><span class="s1">MultiDomainBasicAuth</span>
<span class="s3">from </span><span class="s1">pip._internal.network.cache </span><span class="s3">import </span><span class="s1">SafeFileCache</span>

<span class="s2"># Import ssl from compat so the initial import occurs in only one place.</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.compat </span><span class="s3">import </span><span class="s1">has_tls</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.glibc </span><span class="s3">import </span><span class="s1">libc_ver</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.misc </span><span class="s3">import </span><span class="s1">build_url_from_netloc</span><span class="s3">, </span><span class="s1">parse_netloc</span>
<span class="s3">from </span><span class="s1">pip._internal.utils.urls </span><span class="s3">import </span><span class="s1">url_to_path</span>

<span class="s1">logger = logging.getLogger(__name__)</span>

<span class="s1">SecureOrigin = Tuple[str</span><span class="s3">, </span><span class="s1">str</span><span class="s3">, </span><span class="s1">Optional[Union[int</span><span class="s3">, </span><span class="s1">str]]]</span>


<span class="s2"># Ignore warning raised when using --trusted-host.</span>
<span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;ignore&quot;</span><span class="s3">, </span><span class="s1">category=InsecureRequestWarning)</span>


<span class="s1">SECURE_ORIGINS = [</span>
    <span class="s2"># protocol, hostname, port</span>
    <span class="s2"># Taken from Chrome's list of secure origins (See: http://bit.ly/1qrySKC)</span>
    <span class="s1">(</span><span class="s4">&quot;https&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s4">&quot;localhost&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s4">&quot;127.0.0.0/8&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s4">&quot;::1/128&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">(</span><span class="s4">&quot;file&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s2"># ssh is always secure.</span>
    <span class="s1">(</span><span class="s4">&quot;ssh&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s3">, </span><span class="s4">&quot;*&quot;</span><span class="s1">)</span><span class="s3">,</span>
<span class="s1">]  </span><span class="s2"># type: List[SecureOrigin]</span>


<span class="s2"># These are environment variables present when running under various</span>
<span class="s2"># CI systems.  For each variable, some CI systems that use the variable</span>
<span class="s2"># are indicated.  The collection was chosen so that for each of a number</span>
<span class="s2"># of popular systems, at least one of the environment variables is used.</span>
<span class="s2"># This list is used to provide some indication of and lower bound for</span>
<span class="s2"># CI traffic to PyPI.  Thus, it is okay if the list is not comprehensive.</span>
<span class="s2"># For more background, see: https://github.com/pypa/pip/issues/5499</span>
<span class="s1">CI_ENVIRONMENT_VARIABLES = (</span>
    <span class="s2"># Azure Pipelines</span>
    <span class="s4">'BUILD_BUILDID'</span><span class="s3">,</span>
    <span class="s2"># Jenkins</span>
    <span class="s4">'BUILD_ID'</span><span class="s3">,</span>
    <span class="s2"># AppVeyor, CircleCI, Codeship, Gitlab CI, Shippable, Travis CI</span>
    <span class="s4">'CI'</span><span class="s3">,</span>
    <span class="s2"># Explicit environment variable.</span>
    <span class="s4">'PIP_IS_CI'</span><span class="s3">,</span>
<span class="s1">)</span>


<span class="s3">def </span><span class="s1">looks_like_ci():</span>
    <span class="s2"># type: () -&gt; bool</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether it looks like pip is running under CI. 
    &quot;&quot;&quot;</span>
    <span class="s2"># We don't use the method of checking for a tty (e.g. using isatty())</span>
    <span class="s2"># because some CI systems mimic a tty (e.g. Travis CI).  Thus that</span>
    <span class="s2"># method doesn't provide definitive information in either direction.</span>
    <span class="s3">return </span><span class="s1">any(name </span><span class="s3">in </span><span class="s1">os.environ </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">CI_ENVIRONMENT_VARIABLES)</span>


<span class="s3">def </span><span class="s1">user_agent():</span>
    <span class="s2"># type: () -&gt; str</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a string representing the user agent. 
    &quot;&quot;&quot;</span>
    <span class="s1">data = {</span>
        <span class="s4">&quot;installer&quot;</span><span class="s1">: {</span><span class="s4">&quot;name&quot;</span><span class="s1">: </span><span class="s4">&quot;pip&quot;</span><span class="s3">, </span><span class="s4">&quot;version&quot;</span><span class="s1">: __version__}</span><span class="s3">,</span>
        <span class="s4">&quot;python&quot;</span><span class="s1">: platform.python_version()</span><span class="s3">,</span>
        <span class="s4">&quot;implementation&quot;</span><span class="s1">: {</span>
            <span class="s4">&quot;name&quot;</span><span class="s1">: platform.python_implementation()</span><span class="s3">,</span>
        <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">}  </span><span class="s2"># type: Dict[str, Any]</span>

    <span class="s3">if </span><span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;name&quot;</span><span class="s1">] == </span><span class="s4">'CPython'</span><span class="s1">:</span>
        <span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;version&quot;</span><span class="s1">] = platform.python_version()</span>
    <span class="s3">elif </span><span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;name&quot;</span><span class="s1">] == </span><span class="s4">'PyPy'</span><span class="s1">:</span>
        <span class="s1">pypy_version_info = sys.pypy_version_info  </span><span class="s2"># type: ignore</span>
        <span class="s3">if </span><span class="s1">pypy_version_info.releaselevel == </span><span class="s4">'final'</span><span class="s1">:</span>
            <span class="s1">pypy_version_info = pypy_version_info[:</span><span class="s5">3</span><span class="s1">]</span>
        <span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;version&quot;</span><span class="s1">] = </span><span class="s4">&quot;.&quot;</span><span class="s1">.join(</span>
            <span class="s1">[str(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">pypy_version_info]</span>
        <span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;name&quot;</span><span class="s1">] == </span><span class="s4">'Jython'</span><span class="s1">:</span>
        <span class="s2"># Complete Guess</span>
        <span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;version&quot;</span><span class="s1">] = platform.python_version()</span>
    <span class="s3">elif </span><span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;name&quot;</span><span class="s1">] == </span><span class="s4">'IronPython'</span><span class="s1">:</span>
        <span class="s2"># Complete Guess</span>
        <span class="s1">data[</span><span class="s4">&quot;implementation&quot;</span><span class="s1">][</span><span class="s4">&quot;version&quot;</span><span class="s1">] = platform.python_version()</span>

    <span class="s3">if </span><span class="s1">sys.platform.startswith(</span><span class="s4">&quot;linux&quot;</span><span class="s1">):</span>
        <span class="s3">from </span><span class="s1">pip._vendor </span><span class="s3">import </span><span class="s1">distro</span>

        <span class="s2"># https://github.com/nir0s/distro/pull/269</span>
        <span class="s1">linux_distribution = distro.linux_distribution()  </span><span class="s2"># type: ignore</span>
        <span class="s1">distro_infos = dict(filter(</span>
            <span class="s3">lambda </span><span class="s1">x: x[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">zip([</span><span class="s4">&quot;name&quot;</span><span class="s3">, </span><span class="s4">&quot;version&quot;</span><span class="s3">, </span><span class="s4">&quot;id&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">linux_distribution)</span><span class="s3">,</span>
        <span class="s1">))</span>
        <span class="s1">libc = dict(filter(</span>
            <span class="s3">lambda </span><span class="s1">x: x[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">zip([</span><span class="s4">&quot;lib&quot;</span><span class="s3">, </span><span class="s4">&quot;version&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">libc_ver())</span><span class="s3">,</span>
        <span class="s1">))</span>
        <span class="s3">if </span><span class="s1">libc:</span>
            <span class="s1">distro_infos[</span><span class="s4">&quot;libc&quot;</span><span class="s1">] = libc</span>
        <span class="s3">if </span><span class="s1">distro_infos:</span>
            <span class="s1">data[</span><span class="s4">&quot;distro&quot;</span><span class="s1">] = distro_infos</span>

    <span class="s3">if </span><span class="s1">sys.platform.startswith(</span><span class="s4">&quot;darwin&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">platform.mac_ver()[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s1">data[</span><span class="s4">&quot;distro&quot;</span><span class="s1">] = {</span><span class="s4">&quot;name&quot;</span><span class="s1">: </span><span class="s4">&quot;macOS&quot;</span><span class="s3">, </span><span class="s4">&quot;version&quot;</span><span class="s1">: platform.mac_ver()[</span><span class="s5">0</span><span class="s1">]}</span>

    <span class="s3">if </span><span class="s1">platform.system():</span>
        <span class="s1">data.setdefault(</span><span class="s4">&quot;system&quot;</span><span class="s3">, </span><span class="s1">{})[</span><span class="s4">&quot;name&quot;</span><span class="s1">] = platform.system()</span>

    <span class="s3">if </span><span class="s1">platform.release():</span>
        <span class="s1">data.setdefault(</span><span class="s4">&quot;system&quot;</span><span class="s3">, </span><span class="s1">{})[</span><span class="s4">&quot;release&quot;</span><span class="s1">] = platform.release()</span>

    <span class="s3">if </span><span class="s1">platform.machine():</span>
        <span class="s1">data[</span><span class="s4">&quot;cpu&quot;</span><span class="s1">] = platform.machine()</span>

    <span class="s3">if </span><span class="s1">has_tls():</span>
        <span class="s3">import </span><span class="s1">_ssl </span><span class="s3">as </span><span class="s1">ssl</span>
        <span class="s1">data[</span><span class="s4">&quot;openssl_version&quot;</span><span class="s1">] = ssl.OPENSSL_VERSION</span>

    <span class="s1">setuptools_dist = get_default_environment().get_distribution(</span><span class="s4">&quot;setuptools&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">setuptools_dist </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">data[</span><span class="s4">&quot;setuptools_version&quot;</span><span class="s1">] = str(setuptools_dist.version)</span>

    <span class="s2"># Use None rather than False so as not to give the impression that</span>
    <span class="s2"># pip knows it is not being run under CI.  Rather, it is a null or</span>
    <span class="s2"># inconclusive result.  Also, we include some value rather than no</span>
    <span class="s2"># value to make it easier to know that the check has been run.</span>
    <span class="s1">data[</span><span class="s4">&quot;ci&quot;</span><span class="s1">] = </span><span class="s3">True if </span><span class="s1">looks_like_ci() </span><span class="s3">else None</span>

    <span class="s1">user_data = os.environ.get(</span><span class="s4">&quot;PIP_USER_AGENT_USER_DATA&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">user_data </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">data[</span><span class="s4">&quot;user_data&quot;</span><span class="s1">] = user_data</span>

    <span class="s3">return </span><span class="s4">&quot;{data[installer][name]}/{data[installer][version]} {json}&quot;</span><span class="s1">.format(</span>
        <span class="s1">data=data</span><span class="s3">,</span>
        <span class="s1">json=json.dumps(data</span><span class="s3">, </span><span class="s1">separators=(</span><span class="s4">&quot;,&quot;</span><span class="s3">, </span><span class="s4">&quot;:&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">sort_keys=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s3">class </span><span class="s1">LocalFSAdapter(BaseAdapter):</span>

    <span class="s3">def </span><span class="s1">send(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">request</span><span class="s3">,  </span><span class="s2"># type: PreparedRequest</span>
        <span class="s1">stream=</span><span class="s3">False,  </span><span class="s2"># type: bool</span>
        <span class="s1">timeout=</span><span class="s3">None,  </span><span class="s2"># type: Optional[Union[float, Tuple[float, float]]]</span>
        <span class="s1">verify=</span><span class="s3">True,  </span><span class="s2"># type: Union[bool, str]</span>
        <span class="s1">cert=</span><span class="s3">None,  </span><span class="s2"># type: Optional[Union[str, Tuple[str, str]]]</span>
        <span class="s1">proxies=</span><span class="s3">None,  </span><span class="s2"># type:Optional[Mapping[str, str]]</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; Response</span>
        <span class="s1">pathname = url_to_path(request.url)</span>

        <span class="s1">resp = Response()</span>
        <span class="s1">resp.status_code = </span><span class="s5">200</span>
        <span class="s1">resp.url = request.url</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">stats = os.stat(pathname)</span>
        <span class="s3">except </span><span class="s1">OSError </span><span class="s3">as </span><span class="s1">exc:</span>
            <span class="s1">resp.status_code = </span><span class="s5">404</span>
            <span class="s1">resp.raw = exc</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">modified = email.utils.formatdate(stats.st_mtime</span><span class="s3">, </span><span class="s1">usegmt=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">content_type = mimetypes.guess_type(pathname)[</span><span class="s5">0</span><span class="s1">] </span><span class="s3">or </span><span class="s4">&quot;text/plain&quot;</span>
            <span class="s1">resp.headers = CaseInsensitiveDict({</span>
                <span class="s4">&quot;Content-Type&quot;</span><span class="s1">: content_type</span><span class="s3">,</span>
                <span class="s4">&quot;Content-Length&quot;</span><span class="s1">: stats.st_size</span><span class="s3">,</span>
                <span class="s4">&quot;Last-Modified&quot;</span><span class="s1">: modified</span><span class="s3">,</span>
            <span class="s1">})</span>

            <span class="s1">resp.raw = open(pathname</span><span class="s3">, </span><span class="s4">&quot;rb&quot;</span><span class="s1">)</span>
            <span class="s1">resp.close = resp.raw.close</span>

        <span class="s3">return </span><span class="s1">resp</span>

    <span class="s3">def </span><span class="s1">close(self):</span>
        <span class="s2"># type: () -&gt; None</span>
        <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">InsecureHTTPAdapter(HTTPAdapter):</span>

    <span class="s3">def </span><span class="s1">cert_verify(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">conn</span><span class="s3">,  </span><span class="s2"># type: ConnectionPool</span>
        <span class="s1">url</span><span class="s3">,  </span><span class="s2"># type: str</span>
        <span class="s1">verify</span><span class="s3">,  </span><span class="s2"># type: Union[bool, str]</span>
        <span class="s1">cert</span><span class="s3">,  </span><span class="s2"># type: Optional[Union[str, Tuple[str, str]]]</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; None</span>
        <span class="s1">super().cert_verify(conn=conn</span><span class="s3">, </span><span class="s1">url=url</span><span class="s3">, </span><span class="s1">verify=</span><span class="s3">False, </span><span class="s1">cert=cert)</span>


<span class="s3">class </span><span class="s1">InsecureCacheControlAdapter(CacheControlAdapter):</span>

    <span class="s3">def </span><span class="s1">cert_verify(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">conn</span><span class="s3">,  </span><span class="s2"># type: ConnectionPool</span>
        <span class="s1">url</span><span class="s3">,  </span><span class="s2"># type: str</span>
        <span class="s1">verify</span><span class="s3">,  </span><span class="s2"># type: Union[bool, str]</span>
        <span class="s1">cert</span><span class="s3">,  </span><span class="s2"># type: Optional[Union[str, Tuple[str, str]]]</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; None</span>
        <span class="s1">super().cert_verify(conn=conn</span><span class="s3">, </span><span class="s1">url=url</span><span class="s3">, </span><span class="s1">verify=</span><span class="s3">False, </span><span class="s1">cert=cert)</span>


<span class="s3">class </span><span class="s1">PipSession(requests.Session):</span>

    <span class="s1">timeout = </span><span class="s3">None  </span><span class="s2"># type: Optional[int]</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">*args</span><span class="s3">,  </span><span class="s2"># type: Any</span>
        <span class="s1">retries=</span><span class="s5">0</span><span class="s3">,  </span><span class="s2"># type: int</span>
        <span class="s1">cache=</span><span class="s3">None,  </span><span class="s2"># type: Optional[str]</span>
        <span class="s1">trusted_hosts=()</span><span class="s3">,  </span><span class="s2"># type: Sequence[str]</span>
        <span class="s1">index_urls=</span><span class="s3">None,  </span><span class="s2"># type: Optional[List[str]]</span>
        <span class="s1">**kwargs</span><span class="s3">,  </span><span class="s2"># type: Any</span>
    <span class="s1">):</span>
        <span class="s2"># type: (...) -&gt; None</span>
        <span class="s0">&quot;&quot;&quot; 
        :param trusted_hosts: Domains not to emit warnings for when not using 
            HTTPS. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

        <span class="s2"># Namespace the attribute with &quot;pip_&quot; just in case to prevent</span>
        <span class="s2"># possible conflicts with the base class.</span>
        <span class="s1">self.pip_trusted_origins = []  </span><span class="s2"># type: List[Tuple[str, Optional[int]]]</span>

        <span class="s2"># Attach our User Agent to the request</span>
        <span class="s1">self.headers[</span><span class="s4">&quot;User-Agent&quot;</span><span class="s1">] = user_agent()</span>

        <span class="s2"># Attach our Authentication handler to the session</span>
        <span class="s1">self.auth = MultiDomainBasicAuth(index_urls=index_urls)</span>

        <span class="s2"># Create our urllib3.Retry instance which will allow us to customize</span>
        <span class="s2"># how we handle retries.</span>
        <span class="s1">retries = urllib3.Retry(</span>
            <span class="s2"># Set the total number of retries that a particular request can</span>
            <span class="s2"># have.</span>
            <span class="s1">total=retries</span><span class="s3">,</span>

            <span class="s2"># A 503 error from PyPI typically means that the Fastly -&gt; Origin</span>
            <span class="s2"># connection got interrupted in some way. A 503 error in general</span>
            <span class="s2"># is typically considered a transient error so we'll go ahead and</span>
            <span class="s2"># retry it.</span>
            <span class="s2"># A 500 may indicate transient error in Amazon S3</span>
            <span class="s2"># A 520 or 527 - may indicate transient error in CloudFlare</span>
            <span class="s1">status_forcelist=[</span><span class="s5">500</span><span class="s3">, </span><span class="s5">503</span><span class="s3">, </span><span class="s5">520</span><span class="s3">, </span><span class="s5">527</span><span class="s1">]</span><span class="s3">,</span>

            <span class="s2"># Add a small amount of back off between failed requests in</span>
            <span class="s2"># order to prevent hammering the service.</span>
            <span class="s1">backoff_factor=</span><span class="s5">0.25</span><span class="s3">,</span>
        <span class="s1">)  </span><span class="s2"># type: ignore</span>

        <span class="s2"># Our Insecure HTTPAdapter disables HTTPS validation. It does not</span>
        <span class="s2"># support caching so we'll use it for all http:// URLs.</span>
        <span class="s2"># If caching is disabled, we will also use it for</span>
        <span class="s2"># https:// hosts that we've marked as ignoring</span>
        <span class="s2"># TLS errors for (trusted-hosts).</span>
        <span class="s1">insecure_adapter = InsecureHTTPAdapter(max_retries=retries)</span>

        <span class="s2"># We want to _only_ cache responses on securely fetched origins or when</span>
        <span class="s2"># the host is specified as trusted. We do this because</span>
        <span class="s2"># we can't validate the response of an insecurely/untrusted fetched</span>
        <span class="s2"># origin, and we don't want someone to be able to poison the cache and</span>
        <span class="s2"># require manual eviction from the cache to fix it.</span>
        <span class="s3">if </span><span class="s1">cache:</span>
            <span class="s1">secure_adapter = CacheControlAdapter(</span>
                <span class="s1">cache=SafeFileCache(cache)</span><span class="s3">,</span>
                <span class="s1">max_retries=retries</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">self._trusted_host_adapter = InsecureCacheControlAdapter(</span>
                <span class="s1">cache=SafeFileCache(cache)</span><span class="s3">,</span>
                <span class="s1">max_retries=retries</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">secure_adapter = HTTPAdapter(max_retries=retries)</span>
            <span class="s1">self._trusted_host_adapter = insecure_adapter</span>

        <span class="s1">self.mount(</span><span class="s4">&quot;https://&quot;</span><span class="s3">, </span><span class="s1">secure_adapter)</span>
        <span class="s1">self.mount(</span><span class="s4">&quot;http://&quot;</span><span class="s3">, </span><span class="s1">insecure_adapter)</span>

        <span class="s2"># Enable file:// urls</span>
        <span class="s1">self.mount(</span><span class="s4">&quot;file://&quot;</span><span class="s3">, </span><span class="s1">LocalFSAdapter())</span>

        <span class="s3">for </span><span class="s1">host </span><span class="s3">in </span><span class="s1">trusted_hosts:</span>
            <span class="s1">self.add_trusted_host(host</span><span class="s3">, </span><span class="s1">suppress_logging=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">update_index_urls(self</span><span class="s3">, </span><span class="s1">new_index_urls):</span>
        <span class="s2"># type: (List[str]) -&gt; None</span>
        <span class="s0">&quot;&quot;&quot; 
        :param new_index_urls: New index urls to update the authentication 
            handler with. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.auth.index_urls = new_index_urls</span>

    <span class="s3">def </span><span class="s1">add_trusted_host(self</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s1">source=</span><span class="s3">None, </span><span class="s1">suppress_logging=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2"># type: (str, Optional[str], bool) -&gt; None</span>
        <span class="s0">&quot;&quot;&quot; 
        :param host: It is okay to provide a host that has previously been 
            added. 
        :param source: An optional source string, for logging where the host 
            string came from. 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">suppress_logging:</span>
            <span class="s1">msg = </span><span class="s4">f'adding trusted host: </span><span class="s3">{</span><span class="s1">host</span><span class="s3">!r}</span><span class="s4">'</span>
            <span class="s3">if </span><span class="s1">source </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">msg += </span><span class="s4">f' (from </span><span class="s3">{</span><span class="s1">source</span><span class="s3">}</span><span class="s4">)'</span>
            <span class="s1">logger.info(msg)</span>

        <span class="s1">host_port = parse_netloc(host)</span>
        <span class="s3">if </span><span class="s1">host_port </span><span class="s3">not in </span><span class="s1">self.pip_trusted_origins:</span>
            <span class="s1">self.pip_trusted_origins.append(host_port)</span>

        <span class="s1">self.mount(</span>
            <span class="s1">build_url_from_netloc(host) + </span><span class="s4">'/'</span><span class="s3">,</span>
            <span class="s1">self._trusted_host_adapter</span>
        <span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">host_port[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s2"># Mount wildcard ports for the same host.</span>
            <span class="s1">self.mount(</span>
                <span class="s1">build_url_from_netloc(host) + </span><span class="s4">':'</span><span class="s3">,</span>
                <span class="s1">self._trusted_host_adapter</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">iter_secure_origins(self):</span>
        <span class="s2"># type: () -&gt; Iterator[SecureOrigin]</span>
        <span class="s3">yield from </span><span class="s1">SECURE_ORIGINS</span>
        <span class="s3">for </span><span class="s1">host</span><span class="s3">, </span><span class="s1">port </span><span class="s3">in </span><span class="s1">self.pip_trusted_origins:</span>
            <span class="s3">yield </span><span class="s1">(</span><span class="s4">'*'</span><span class="s3">, </span><span class="s1">host</span><span class="s3">, </span><span class="s4">'*' </span><span class="s3">if </span><span class="s1">port </span><span class="s3">is None else </span><span class="s1">port)</span>

    <span class="s3">def </span><span class="s1">is_secure_origin(self</span><span class="s3">, </span><span class="s1">location):</span>
        <span class="s2"># type: (Link) -&gt; bool</span>
        <span class="s2"># Determine if this url used a secure transport mechanism</span>
        <span class="s1">parsed = urllib.parse.urlparse(str(location))</span>
        <span class="s1">origin_protocol</span><span class="s3">, </span><span class="s1">origin_host</span><span class="s3">, </span><span class="s1">origin_port = (</span>
            <span class="s1">parsed.scheme</span><span class="s3">, </span><span class="s1">parsed.hostname</span><span class="s3">, </span><span class="s1">parsed.port</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s2"># The protocol to use to see if the protocol matches.</span>
        <span class="s2"># Don't count the repository type as part of the protocol: in</span>
        <span class="s2"># cases such as &quot;git+ssh&quot;, only use &quot;ssh&quot;. (I.e., Only verify against</span>
        <span class="s2"># the last scheme.)</span>
        <span class="s1">origin_protocol = origin_protocol.rsplit(</span><span class="s4">'+'</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2"># Determine if our origin is a secure origin by looking through our</span>
        <span class="s2"># hardcoded list of secure origins, as well as any additional ones</span>
        <span class="s2"># configured on this PackageFinder instance.</span>
        <span class="s3">for </span><span class="s1">secure_origin </span><span class="s3">in </span><span class="s1">self.iter_secure_origins():</span>
            <span class="s1">secure_protocol</span><span class="s3">, </span><span class="s1">secure_host</span><span class="s3">, </span><span class="s1">secure_port = secure_origin</span>
            <span class="s3">if </span><span class="s1">origin_protocol != secure_protocol </span><span class="s3">and </span><span class="s1">secure_protocol != </span><span class="s4">&quot;*&quot;</span><span class="s1">:</span>
                <span class="s3">continue</span>

            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">addr = ipaddress.ip_address(origin_host)</span>
                <span class="s1">network = ipaddress.ip_network(secure_host)</span>
            <span class="s3">except </span><span class="s1">ValueError:</span>
                <span class="s2"># We don't have both a valid address or a valid network, so</span>
                <span class="s2"># we'll check this origin against hostnames.</span>
                <span class="s3">if </span><span class="s1">(</span>
                    <span class="s1">origin_host </span><span class="s3">and</span>
                    <span class="s1">origin_host.lower() != secure_host.lower() </span><span class="s3">and</span>
                    <span class="s1">secure_host != </span><span class="s4">&quot;*&quot;</span>
                <span class="s1">):</span>
                    <span class="s3">continue</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># We have a valid address and network, so see if the address</span>
                <span class="s2"># is contained within the network.</span>
                <span class="s3">if </span><span class="s1">addr </span><span class="s3">not in </span><span class="s1">network:</span>
                    <span class="s3">continue</span>

            <span class="s2"># Check to see if the port matches.</span>
            <span class="s3">if </span><span class="s1">(</span>
                <span class="s1">origin_port != secure_port </span><span class="s3">and</span>
                <span class="s1">secure_port != </span><span class="s4">&quot;*&quot; </span><span class="s3">and</span>
                <span class="s1">secure_port </span><span class="s3">is not None</span>
            <span class="s1">):</span>
                <span class="s3">continue</span>

            <span class="s2"># If we've gotten here, then this origin matches the current</span>
            <span class="s2"># secure origin and we should return True</span>
            <span class="s3">return True</span>

        <span class="s2"># If we've gotten to this point, then the origin isn't secure and we</span>
        <span class="s2"># will not accept it as a valid location to search. We will however</span>
        <span class="s2"># log a warning that we are ignoring it.</span>
        <span class="s1">logger.warning(</span>
            <span class="s4">&quot;The repository located at %s is not a trusted or secure host and &quot;</span>
            <span class="s4">&quot;is being ignored. If this repository is available via HTTPS we &quot;</span>
            <span class="s4">&quot;recommend you use HTTPS instead, otherwise you may silence &quot;</span>
            <span class="s4">&quot;this warning and allow it anyway with '--trusted-host %s'.&quot;</span><span class="s3">,</span>
            <span class="s1">origin_host</span><span class="s3">,</span>
            <span class="s1">origin_host</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s3">return False</span>

    <span class="s3">def </span><span class="s1">request(self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s2"># type: (str, str, *Any, **Any) -&gt; Response</span>
        <span class="s2"># Allow setting a default timeout on a session</span>
        <span class="s1">kwargs.setdefault(</span><span class="s4">&quot;timeout&quot;</span><span class="s3">, </span><span class="s1">self.timeout)</span>

        <span class="s2"># Dispatch the actual request</span>
        <span class="s3">return </span><span class="s1">super().request(method</span><span class="s3">, </span><span class="s1">url</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
</pre>
</body>
</html>